<?php
/**
 * This file is part of SinergiaCRM.
 * SinergiaCRM is a work developed by SinergiaTIC Association, based on SuiteCRM.
 * Copyright (C) 2013 - 2023 SinergiaTIC Association
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License version 3 as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License along with
 * this program; if not, see http://www.gnu.org/licenses or write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA.
 *
 * You can contact SinergiaTIC Association at email address info@sinergiacrm.org.
 */

require_once __DIR__ . '/../../WebFormDataBO.php';
/**
 * Class that contains the logic of the payment methods model for payments from web forms
 */
class PaymentBO extends WebFormDataBO
{
    protected $actionDefFields = array('type', 'assigned_user_id'); // Array with the invariable data
    protected $defFields = array('payment_method', 'payment_type'); // Array with the definition fields of any form
    protected $formFields = array(); // Array with the expected field identifiers of the form
    protected $requiredFormFields = array('amount'); // Array indicating the fields required form
    protected $lastPC = null; // It contains the last form of payment generated
    protected $lastPayment = null; // It contains the last payment generated

    public function getObjectsCreated()
    {
        return array(
            'stic_Payment_Commitments' => $this->getLastPC(),
            'stic_Payments' => $this->getLastPayment()
        );
    }

    /**
     * Returns the last form of payment generated by this object
     */
    public function getLastPC()
    {
        return $this->lastPC;
    }

    /**
     * Returns the last payment generated by this object
     */
    public function getLastPayment()
    {
        return $this->lastPayment;
    }

    protected function setLastPC($fp)
    {
        $this->lastPC = $fp;
    }

    protected function setLastPayment($payment)
    {
        $this->lastPayment = $payment;
    }

    /**
     * Overload of the request parameter management method since in this case, the parameters may vary if there is payment by card
     */
    public function checkActionDefParams()
    {
        $param = $this->getParam('type');
        $ret = '';
        switch ($param) {
            // If this is the first step of a payment we will need values on payment method and type
            case PaymentController::RESPONSE_TYPE_NEW_PAYMENT:
                $this->defFields = array('payment_method', 'payment_type');
                $this->requiredDefFields = $this->defFields;
                break;
            // If it is a POS Redsys response, we do not need a definition field
            case PaymentController::RESPONSE_TYPE_TPV_RESPONSE:
                $this->defFields = array();
                $this->requiredDefFields = array();
                break;
            // If it is a POS CECA response, we do not need a definition field
            case PaymentController::RESPONSE_TYPE_TPVCECA_RESPONSE:
                $this->defFields = array();
                $this->requiredDefFields = array();
                break;
            // If it is a Paypal answer, we do not need a definition field
            case PaymentController::RESPONSE_TYPE_PAYPAL_RESPONSE:
                $this->defFields = array();
                $this->requiredDefFields = array();
                break;
            // If it is a Stripe answer, we do not need a definition field
            case PaymentController::RESPONSE_TYPE_STRIPE_RESPONSE:
                $this->defFields = array();
                $this->requiredDefFields = array();
                break;
            // It cannot be a different request parameter
            default:
                $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ":  Type of request [{$param}] is invalid, cannot continue.");
                $ret = 'UNEXPECTED_ERROR';
        }
        return $this->returnCode($ret);
    }

    /**
     * Returns the fields to retrieve from the form
     */
    public function getFormFields()
    {
        $param = $this->getParam('type');
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ":  Generating field list for type [{$param}]...");
        switch ($param) {
            // We generate the necessary fields for the first step of a form
            case PaymentController::RESPONSE_TYPE_NEW_PAYMENT:
                // On direct debit payments the bank account is a required field
                if ($this->defParams['payment_method'] == 'direct_debit') {
                    $this->requiredFormFields[] = 'bank_account';
                }

                // Periodicity is always required
                $this->requiredFormFields[] = 'periodicity';

                $bean = Beanfactory::getBean('stic_Payment_Commitments');

                // Add possible fields to retrieve
                foreach ($bean->field_defs as $field_def) {
                    $this->formFields[] = $field_def['name'];
                }
                break;

            // Set the required fields for a POS payment answer
            case PaymentController::RESPONSE_TYPE_TPV_RESPONSE:
                $this->formFields = array('Ds_SignatureVersion', 'Ds_Signature', 'Ds_MerchantParameters');
                $this->requiredFormFields = $this->formFields;
                break;

            // Set the required fields for a POS payment answer
            case PaymentController::RESPONSE_TYPE_TPVCECA_RESPONSE:
                $this->formFields = array('MerchantID', 'AcquirerBIN', 'TerminalID', 'Num_operacion', 'Importe', 'Firma');
                $this->requiredFormFields = $this->formFields;
                break;

            // Set the required fields for a Paypal payment answer
            case PaymentController::RESPONSE_TYPE_PAYPAL_RESPONSE:
                $this->formFields = array('custom');
                $this->requiredFormFields = $this->formFields;
                break;
            // Set the required fields for a Stripe payment answer: None
            case PaymentController::RESPONSE_TYPE_STRIPE_RESPONSE:
                $this->formFields = array();
                $this->requiredFormFields = $this->formFields;
                break;
        }

        return $this->formFields;
    }

    /**
     * Generates a payment commitment based upon the data indicated in the object
     * @return Object The payment details if it has been created or null otherwise
     */
    public function newPayment($namePrefix = '')
    {
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Generating a new payment commitment...");
        $this->setLastPC(null);
        $this->setLastPayment(null);

        // Load the data sent by the web form in a new payment commitment bean
        $fp = $this->newBeanFromParams('stic_Payment_Commitments', false);

        // Set or update some fields: description, channel and amount
        if (!empty($this->formParams['description'])) {
            $fp->description = $this->formParams['description'];
        } else {
            $fp->description = $GLOBALS['app_list_strings'][$fp->field_defs['payment_type']['options']][$this->formParams['payment_type']] . ' web';
        }
        $fp->channel = 'web';
        $fp->amount = currency_format_number($this->formParams['amount'], array('currency_symbol' => false));

        // If first_payment_date has not been sent by the web form or is not right (YYYY-MM-DD) then set it to current date
        $dateExplode = explode('-', $fp->first_payment_date);
        if (empty($fp->first_payment_date) || !checkDate($dateExplode[1], $dateExplode[2], $dateExplode[0])) {
            $fp->first_payment_date = date('Y-m-d');
        }

        // 1) In recurring card payments, first payment date can't be in the past
        // 2) In single card payments and in PayPal, first payment date must be today
        // If prior conditions are not verified, then set first payment date to current date
        $paymentMethodIsCard = $fp->payment_method == 'ceca_card' || substr($fp->payment_method, 0, 10) == 'ceca_card_' || $fp->payment_method == 'card' || substr($fp->payment_method, 0, 5) == 'card_' ? true : false;
        if (
            ($paymentMethodIsCard == true && $fp->first_payment_date < date('Y-m-d'))
            || ($paymentMethodIsCard == true && $fp->first_payment_date != date('Y-m-d') && $fp->periodicity == 'punctual')
            || ($fp->payment_method == 'paypal')
        ) {
            $fp->first_payment_date = date('Y-m-d');
        }

        // In a direct debit payment, properly format the bank account and generate the mandate
        if ($fp->payment_method == 'direct_debit') {
            $bank_account = str_replace('-', '', $this->formParams['bank_account']);
            $bank_account = str_replace(' ', '', $bank_account);

            $fp->bank_account = strtoupper($bank_account);
            $fp->mandate = mt_rand(10000000, 99999999);
        }

        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Payment commitment: " . print_r($fp, true));

        // Link the payment commitment with the contact or the account
        if ($this->payer->module_name == "Contacts") {
            $fp->stic_payment_commitments_contactscontacts_ida = $this->payer->id;
            $fp->name = trim($this->payer->first_name . ' ' . $this->payer->last_name);
        } else if ($this->payer->module_name == "Accounts") {
            $fp->stic_payment_commitments_accountsaccounts_ida = $this->payer->id;
            $fp->name = $this->payer->name;
        }

        // Get the payment type
        $lblPaymentType = $GLOBALS['app_list_strings'][$fp->field_defs['payment_type']['options']][$fp->payment_type];
        if (!$lblPaymentType) {
            $lblPaymentType = $fp->payment_type;
        }

        // Complete payment commitment name
        $namePrefix = (empty($namePrefix) ? '' : " - {$namePrefix}");
        $fp->name .= ' - ' . $lblPaymentType . $namePrefix . ' - ' . $fp->amount;

        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": New payment commitment name: {$fp->name}");

        // Save the new payment commitment (a payment will be automatically generated within a LH)
        $fp->save(false);
        $this->setLastPC($fp);

        // Reload the payment commitment bean in order to properly load relationships
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Reloading payment commitment...");
        $fp->retrieve($fp->id);

        // Get the generated payment
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Loading the related payment...");
        $fp->load_relationship('stic_payments_stic_payment_commitments');
        $payments = $fp->stic_payments_stic_payment_commitments->getBeans();

        if (empty($payments) || count($payments) < 1) {
            $GLOBALS['log']->error('Line ' . __LINE__ . ': ' . __METHOD__ . ": An error occurred while trying to set the payment status");
            $this->returnCode('UNEXPECTED_ERROR');
            return null;
        } else {
            $payment = reset($payments); // Get the first element in the array
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Got payment {$payment->id}");
            if ($fp->payment_method == 'card' || $fp->payment_method == 'paypal' || $fp->payment_method == 'bizum') {
                // POS/Paypal payments must be set as pending
                $payment->status = 'pending';
                $payment->save(); // Save the changes
            }

            // Reload the object since otherwise will not have reported the id (mysteries of sugar)
            $payment = $payment->retrieve($payment->id);
            $this->setLastPayment($payment);

            return $payment; // Returns the payment generated
        }
    }

    /**
     * Get the TPV(redsys) settings
     */
    public static function getTPVSettings($paymentMethod)
    {
        // Add variable TPV values from settings (filtered by payment_method)
        require_once "modules/stic_Settings/Utils.php";
        $settingsTPV = stic_SettingsUtils::getTPVSettings($paymentMethod);

        // Add permanent TPV values
        $settingsTPV['TPV_SERVER_URL'] = 'https://sis.redsys.es/sis/realizarPago';
        $settingsTPV['TPV_SERVER_URL_TEST'] = 'https://sis-t.redsys.es:25443/sis/realizarPago';
        $settingsTPV['TPV_VERSION'] = 'HMAC_SHA256_V1';
        $settingsTPV['TPV_VERSION_TEST'] = 'HMAC_SHA256_V1';

        if ($settingsTPV == null) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ":  Could not load TPV related settings.");
            return null;
        } else {
            // Generates the array with settings that are not in the CRM
            $fixedSettings = array(
                'TPV_MERCHANT_URL' => self::getMerchantURL(),
                'TPV_TRANSACTION_TYPE' => 0,
            );

            // Execution mode-dependent settings (TEST / PRODUCTION)
            $dependentTestConst = array('TPV_VERSION', 'TPV_PASSWORD', 'TPV_SERVER_URL');

            // Settings that are in the CRM and do not depend on the execution environment
            $nonTestDependentConst = array('TPV_MERCHANT_NAME', 'TPV_CURRENCY', 'TPV_MERCHANT_CODE', 'TPV_TERMINAL', 'TPV_TEST');

            // Get execution mode (TEST / PRODUCTION)
            $mode = $settingsTPV['TPV_TEST'];
            $test = "";
            switch ($mode) {
                case '0':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}] PRODUCTION.");
                    break;
                case '1':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}] TEST.");
                    $test = "_TEST";
                    break;
                default:
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}]. Invalid value, please check TPV_TEST setting.");
                    return null;
            }

            // Start the return array with the values set outside the database
            $filteredConst = array();
            foreach ($fixedSettings as $key => $value) {
                $filteredConst[$key] = $value;
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding virtual setting [{$key}] = [{$value}]...");
            }

            // Add settings not dependent on the execution mode
            foreach ($nonTestDependentConst as $key) {
                $filteredConst[$key] = $settingsTPV[$key];
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding setting independent of mode [{$key}] = [{$settingsTPV[$key]}]...");
            }

            // Add the environment dependent settings
            foreach ($dependentTestConst as $key) {
                $setting = $settingsTPV[$key . $test];
                $newKey = str_replace($test, '', $key);
                $filteredConst[$newKey] = $setting;
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Filtered setting [{$newKey}] = [{$setting}].");
            }

            return $filteredConst;
        }
    }
    /**
     * Get the TPVCECA settings
     */
    public static function getTPVCECASettings($paymentMethod)
    {
        // Add variable TPVCECA values from settings (filtered by payment_method)
        require_once "modules/stic_Settings/Utils.php";
        $settingsTPV = stic_SettingsUtils::getTPVSettings($paymentMethod);

        // Add permanent TPV values
        $settingsTPV['TPVCECA_SERVER_URL'] = 'https://pgw.ceca.es/tpvweb/tpv/compra.action';
        $settingsTPV['TPVCECA_SERVER_URL_TEST'] = 'https://tpv.ceca.es/tpvweb/tpv/compra.action';
        $settingsTPV['TPVCECA_VERSION'] = 'HMAC_SHA256_V1';
        $settingsTPV['TPVCECA_VERSION_TEST'] = 'HMAC_SHA256_V1';

        if ($settingsTPV == null) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ":  Could not load TPV related settings.");
            return null;
        } else {
            // Generates the array with settings that are not in the CRM
            $fixedSettings = array(
                'TPVCECA_MERCHANT_URL' => self::getMerchantURL('TPVCECA'),
            );

            // Execution mode-dependent settings (TEST / PRODUCTION)
            $dependentTestConst = array('TPVCECA_VERSION', 'TPVCECA_PASSWORD', 'TPVCECA_SERVER_URL');

            // Settings that are in the CRM and do not depend on the execution environment
            $nonTestDependentConst = array('TPVCECA_MERCHANT_CODE', 'TPVCECA_CURRENCY', 'TPVCECA_ACQUIRER_BIN', 'TPVCECA_TERMINAL', 'TPVCECA_TEST');

            // Get execution mode (TEST / PRODUCTION)
            $mode = $settingsTPV['TPVCECA_TEST'];
            $test = "";
            switch ($mode) {
                case '0':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}] PRODUCTION.");
                    break;
                case '1':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}] TEST.");
                    $test = "_TEST";
                    break;
                default:
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": POS/TPV operating in mode [{$mode}]. Invalid value, please check TPVCECA_TEST setting.");
                    return null;
            }

            // Start the return array with the values set outside the database
            $filteredConst = array();
            foreach ($fixedSettings as $key => $value) {
                $filteredConst[$key] = $value;
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding virtual setting [{$key}] = [{$value}]...");
            }

            // Add settings not dependent on the execution mode
            foreach ($nonTestDependentConst as $key) {
                $filteredConst[$key] = $settingsTPV[$key];
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding setting independent of mode [{$key}] = [{$settingsTPV[$key]}]...");
            }

            // Add the environment dependent settings
            foreach ($dependentTestConst as $key) {
                $setting = $settingsTPV[$key . $test];
                $newKey = str_replace($test, '', $key);
                $filteredConst[$newKey] = $setting;
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Filtered setting [{$newKey}] = [{$setting}].");
            }

            return $filteredConst;
        }
    }

    /**
     *  Returns the settings linked to Paypal
     */
    public static function getPaypalSettings()
    {
        // Add variables paypal values from Settings
        require_once "modules/stic_Settings/Utils.php";
        $settingsPaypal = stic_SettingsUtils::getSettingsByType('PAYPAL');

        // Add permanent paypal values
        $settingsPaypal['PAYPAL_URL'] = 'https://www.paypal.com/cgi-bin/webscr';
        $settingsPaypal['PAYPAL_URL_TEST'] = 'https://www.sandbox.paypal.com/cgi-bin/webscr';

        if ($settingsPaypal == null) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": Could not load settings related to PAYPAL.");
            return null;
        } else {
            // Settings dependent on the mode of execution (TEST/PRODUCTION)
            $dependentTestConst = array('PAYPAL_URL', 'PAYPAL_ID');

            // Get execution mode (TEST / PRODUCTION)
            $mode = $settingsPaypal['PAYPAL_TEST'];
            $test = "";
            switch ($mode) {
                case '0':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": PAYPAL running in mode [{$mode}] PRODUCTION.");
                    $test = "";
                    break;
                case '1':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": PAYPAL running in mode [{$mode}] TEST.");
                    $test = "_TEST";
                    break;
                default:
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": PAYPAL running in mode [{$mode}]. Invalid value, check PAYPAL_TEST setting.");
                    return null; // If we have an invalid mode we will leave here
            }

            // Add the environment dependent settings
            foreach ($dependentTestConst as $key) {
                $setting = $settingsPaypal[$key . $test];
                $filteredConst[$key] = $setting;
                $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ":  Filtered setting [{$key}] = [{$setting}].");
            }

            return $filteredConst;
        }
    }

    /**
     *  Returns the settings linked to Stripe
     */
    public static function getStripeSettings()
    {
        require_once "modules/stic_Settings/Utils.php";

        // Settings are a pair of keys, allowing multiple configurations: 
        // Single config:
        //     STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET (production)
        //     STRIPE_SECRET_KEY_TEST, STRIPE_WEBHOOK_SECRET_TEST (test)
        // Multiple config:
        //     STRIPE_ALT_XXXX_SECRET_KEY, STRIPE_ALT_XXXX_WEBHOOK_SECRET (Config for "XXXX" in production)
        //     STRIPE_ALT_XXXX_SECRET_KEY_TEST, STRIPE_ALT_XXXX_WEBHOOK_SECRET_TEST (Config for "XXXX" in test)

        $settingsStripe = stic_SettingsUtils::getSettingsByType('STRIPE');

        if ($settingsStripe == null) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": Could not load settings related to STRIPE.");
            return null;
        } else {
            // Get execution mode (TEST / PRODUCTION)
            $mode = $settingsStripe['STRIPE_TEST'];
            switch ($mode) {
                case '0':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": STRIPE running in mode [{$mode}] PRODUCTION.");
                    break;
                case '1':
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": STRIPE running in mode [{$mode}] TEST.");
                    break;
                default:
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": STRIPE running in mode [{$mode}]. Invalid value, check STRIPE_TEST setting.");
                    return null; // If we have an invalid mode we will leave here
            }
            foreach ($settingsStripe as $key => $value) {
                // Check if is a "SECRET_KEY", then find related WEBHOOK_SECRET and add the pair to returning Settings
                if (str_ends_with($key, "SECRET_KEY") || str_ends_with($key, "SECRET_KEY_TEST")) {
                    if (($mode == '0' && !str_ends_with($key, "_TEST") && str_starts_with($key, "STRIPE_")) ||
                        ($mode == '1' &&  str_ends_with($key, "_TEST") && str_starts_with($key, "STRIPE_"))) {

                        // Find the WEBHOOK_SECRET
                        $webHookSecretKey = str_replace("SECRET_KEY", "WEBHOOK_SECRET", $key);
                        if(!isset($settingsStripe[$webHookSecretKey])) {
                            $GLOBALS['log']->warn('Line ' . __LINE__ . ': ' . __METHOD__ . ": STRIPE missing Setting {$webHookSecretKey}; Ignoring {$key}, check STRIPE settings.");
                        } else {
                            // Get the config Key (XXXX for STRIPE_ALT_XXXX_SECRET_KEY and STRIPE_ALT_XXXX_SECRET_KEY_TEST)
                            $configKey = (str_starts_with($key, "STRIPE_ALT_")) ? str_replace(array("_TEST","STRIPE_ALT_","_SECRET_KEY"), "", $key) : "";
                            $stripeConsts[$configKey]['STRIPE_SECRET_KEY'] = $value;
                            $stripeConsts[$configKey]['STRIPE_WEBHOOK_SECRET'] = $settingsStripe[$webHookSecretKey];

                            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding virtual setting [{$configKey}]['STRIPE_SECRET_KEY'] = [{$value}]...");
                            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Adding virtual setting [{$configKey}]['STRIPE_WEBHOOK_SECRET'] = [{$settingsStripe[$webHookSecretKey]}]...");
                        }
                    }
                }
            }
            return $stripeConsts;
        }
    }

    /**
     * Generate the response address of a POS request
     */
    private static function getMerchantURL($tpvType = 'TPV')
    {

        $entryPoint = $tpvType == 'TPVCECA' ? 'stic_Web_Forms_tpv_ceca_response' : 'stic_Web_Forms_tpv_response';

        require_once 'modules/stic_Web_Forms/controller.php';
        $server = stic_Web_FormsController::getServerURL();
        $url = "{$server}/index.php?entryPoint={$entryPoint}";
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ":  {$url}");
        return $url;
    }

    /**
     *  Returns the language code for the POS associated with the $lang
     *  TODO: Include codes of all languages
     *  Francés-004, Alemán-005, Holandés-006, Italiano-007, Sueco-008, Portugués-009, Valenciano-010, Polaco-011, Gallego-012
     */
    public static function getTPVLanguage($lang)
    {
        $codes = array(
            'es' => '001', // Spanish
            'en' => '002', // English
            'ca' => '003', // Catalan
            'eu' => '013', // Basque
            '' => '0', // Undefined
        );

        $code = $codes[substr($lang, 0, 2)];
        return (!empty($code) ? $code : $codes['']);
    }

    /**
     * Process the tpv response data
     * Values of $tpvParams:
     *  - "Ds_Date"
     *  - "Ds_Hour"
     *  - "Ds_SecurePayment"
     *  - "Ds_Card_Country"
     *  - "Ds_Amount"
     *  - "Ds_Currency"
     *  - "Ds_Order"
     *  - "Ds_MerchantCode"
     *  - "Ds_Terminal"
     *  - "Ds_Response"
     *  - "Ds_MerchantData"
     *  - "Ds_TransactionType"
     *  - "Ds_ConsumerLanguage"
     *  - "Ds_AuthorisationCode"
     *
     * Valid responses contain a value from 0 to 99 in the field Ds_Response
     * https://www.deutsche-bank.es/pbc/docs/etpv_guia_instalacion_v2-5.pdf
     * TODO: Treat recurring requests with a card
     */
    public function proccessTPVResponse($tpvParams)
    {
        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Processing POS response... -> " . print_r($tpvParams, true));

        // Check the necessary parameters
        if (!isset($tpvParams['Ds_Response']) || !isset($tpvParams['Ds_Order'])) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": Missing data needed to process the request [{$tpvParams['Ds_Response']}] [{$tpvParams['Ds_Order']}].");
            return $this->returnCode('UNEXPECTED_ERROR');
        }

        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Retrieving payment data...");
        $transaction_code = intval($tpvParams['Ds_Order']);
        $payment = Beanfactory::getBean('stic_Payments');
        $payment->retrieve_by_string_fields(array('transaction_code' => $transaction_code));
        if ($payment == null) {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": Error retrieving payment data for transaction code [{$transaction_code}].");
            return $this->returnCode('UNEXPECTED_ERROR');
        }

        $result = intval($tpvParams['Ds_Response']);
        $ret = '';

        // Process valid responses
        if (($result >= 0 && $result <= 99) || $result == 900) {
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Payment [{$payment->payment_method}] successfully done. TPV response: [{$result}].");

            // If the amount is 0 then it is just an authorization (no payment has been processed), so keep the payment as "not_remitted"
            if ($tpvParams['Ds_Amount'] > 0) {
                $payment->status = 'paid';
            } else {
                $payment->status = 'not_remitted';
            }

            // If TPV response includes data for recurring payments then save it in the payment commitment
            if (!empty($tpvParams['Ds_Merchant_Identifier']) && !empty($tpvParams['Ds_ExpiryDate']) && !empty($tpvParams['Ds_Merchant_Cof_Txnid'])) {
                require_once 'SticInclude/Utils.php';
                $PCBean = SticUtils::getRelatedBeanObject($payment, 'stic_payments_stic_payment_commitments');
                $PCBean->redsys_ds_merchant_identifier = $tpvParams['Ds_Merchant_Identifier'];
                $PCBean->card_expiry_date = $tpvParams['Ds_ExpiryDate'];
                $PCBean->redsys_ds_merchant_cof_txnid = $tpvParams['Ds_Merchant_Cof_Txnid'];
                $PCBean->save(false);
            }

        } else {
            require_once 'modules/stic_Web_Forms/Catcher/Include/Payment/lib/RedsysResponseCodes.php';

            $error = !empty($redsysResponseCode[$result]) ? "[{$result}] " . $redsysResponseCode[$result] : 'Undefined Redsys error';

            $GLOBALS['log']->error('Line ' . __LINE__ . ': ' . __METHOD__ . ": Payment [{$payment->id}] failed. TPV response: [{$error}].");

            $payment->status = 'rejected_gateway';
            $payment->gateway_rejection_reason = $error;

            // If payment is rejected the related payment commitment might be cancelled if it is a recurring one
            self::disablePaymentCommitment($payment);

            $ret = $this->returnCode('TPV_REJECTED');
        }

        $payment->save();

        return $this->returnCode($ret);
    }

    // Processes the CECA TPV response after verifying the signature's validity and the presence of all required data.
    public function proccessTPVCECAResponse($tpvParams)
    {
        // Ensure that the operation number and payment ID are present in the request.
        if (!isset($_REQUEST['Num_operacion']) || !isset($_REQUEST['paymentId'])) {
            // Return an error code if any required data is missing from the request.
            return $this->returnCode('UNEXPECTED_ERROR');
        }

        // Retrieve the payment information based on the payment ID provided in the TPV parameters.
        $paymentBean = BeanFactory::getBean('stic_Payments', $tpvParams['paymentId']);

        // If payment data retrieval fails, log the error and return an error code.
        if ($paymentBean == null) {
            return $this->returnCode('UNEXPECTED_ERROR');
        }

        // Determine the payment status based on the presence of a reference or an error code in the TPV parameters.
        if (!empty($tpvParams['Referencia'])) {
            // If a reference is present, mark the payment as successful.
            $paymentBean->status = 'paid';
            $ret = '';
        } elseif (!empty($tpvParams['Codigo_error'])) {
            // If an error code is present, mark the payment as rejected and specify the rejection reason.
            require_once 'modules/stic_Web_Forms/Catcher/Include/Payment/lib/CecaResponseCodes.php';
            $paymentBean->status = 'rejected_gateway';
            $paymentBean->gateway_rejection_reason = $tpvParams['Codigo_error'] . ' - ' . $cecaResponseCode[$tpvParams['Codigo_error']];
            $ret = 'TPVCECA_REJECTED';
        } else {
            return $this->returnCode('UNEXPECTED_ERROR');
        }

        // Save the updated payment information.
        $paymentBean->save();

        // Return a code indicating the outcome of the processing.
        return $this->returnCode($ret);
    }

    /**
     *  Process the paypal response data
     */
    public function proccessPaypalResponse($ipnMessage)
    {
        require_once 'modules/stic_Web_Forms/Catcher/Include/Payment/PaymentMailer.php';
        require_once 'include/utils.php';
        $paymentMailer = new PaymentMailer();

        $txnType = $ipnMessage['txn_type'];

        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Processing PayPal response (IPN notification) Type: [{$txnType}] Content:" . print_r($ipnMessage, true));

        // Switch the message type
        switch ($txnType) {

            case 'web_accept': // Standard one-time payment
            case 'subscr_payment': // Subscription (recurring) payment
                $paymentStatus = $ipnMessage['payment_status'];
                $ret = '';
                $paymentBean = $this->getPaymentByIPNMessage($ipnMessage);
                if (!empty($paymentBean)) {
                    if ($paymentStatus == 'Completed') {
                        $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": {$paymentBean->name} successfully processed. PayPal data: [message: {$txnType}] [status: {$paymentStatus}] [subscr_id (only for recurring payments): {$ipnMessage['subscr_id']}]");
                        $paymentBean->status = 'paid';
                        $paymentBean->amount = intval($ipnMessage['mc_gross']);
                    } else {
                        $GLOBALS['log']->error('Line ' . __LINE__ . ': ' . __METHOD__ . ": {$paymentBean->name} unsuccessfully processed. PayPal data: [message: {$txnType}] [status: {$paymentStatus}] [subscr_id (only for recurring payments): {$ipnMessage['subscr_id']}]");
                        $paymentBean->status = 'rejected_gateway';
                        $ret = $this->returnCode('PAYPAL_REJECTED');
                    }
                    $paymentBean->gateway_log .= '##### ' . print_r($ipnMessage, true);
                    $paymentBean->save();
                } else {
                    // Send IPN message to all admin users
                    $body = "<div><h3>Paypal IPN [{$txnType}]</h3><pre>" . print_r($ipnMessage, true) . '</pre></div>';
                    $subject = translate('LBL_PAYPAL_ADMIN_CANT_GET_PAYMENT', 'stic_Web_Forms') . " [{$txnType}]";
                    $paymentMailer->sendPaypalInfo('', $subject, $body);
                }
                break;

            case 'subscr_signup': // Subscription authorization
                // Save in the payment commitment the data for recurring PayPal payments
                $PCBean = $this->getPaymentCommitmentByIPNTransactionCode($ipnMessage['custom']);
                if (!empty($PCBean)) {
                    $PCBean->paypal_subscr_id = $ipnMessage['subscr_id'];
                    $PCBean->gateway_log .= '###### ' . print_r($ipnMessage, true);
                    $PCBean->save(false);
                } else {
                    // Send IPN message to all admin users
                    $body = "<div><h3>Paypal IPN [{$txnType}]</h3><pre>" . print_r($ipnMessage, true) . '</pre></div>';
                    $subject = translate('LBL_PAYPAL_ADMIN_CANT_GET_PAYMENT_COMMITMENT', 'stic_Web_Forms') . " [{$txnType}]";
                    $paymentMailer->sendPaypalInfo('', $subject, $body);
                }
                break;

            case 'subscr_cancel': // Subscription is cancelled by either organization or donor
                $PCBean = $this->getPaymentCommitmentByIPNSubscrId($ipnMessage['subscr_id']);
                if (!empty($PCBean)) {
                    // Set end_date in payment commitment to deactivate it
                    $PCBean->end_date = date('Y-m-d');
                    $PCBean->gateway_log .= '###### ' . print_r($ipnMessage, true);
                    $PCBean->save(false);
                    $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": {$PCBean->name}. PayPal subscription {$ipnMessage['subscr_id']} has been cancelled.");

                    // Notify the assigned user
                    $body = translate('LBL_PAYPAL_ADMIN_CANCEL_SUBSCRIPTION_INFO', 'stic_Web_Forms') . ': <ul><li>' . translate('LBL_PAYPAL_SUBSCR_ID', 'stic_Payment_Commitments') . ': ' . $PCBean->paypal_subscr_id . '<li>' . translate('LBL_NAME', 'stic_Payment_Commitments') . ':  <a href="' . $paymentMailer->createLinkToDetailView('stic_Payment_Commitments', $PCBean->id) . '">' . $PCBean->name . '</a><li>' . translate('LBL_END_DATE', 'stic_Payment_Commitments') . ': ' . $PCBean->end_date . '</ul>';
                    $body .= '<div><h3>IPN</h3><pre>' . print_r($ipnMessage, true) . '</pre></div>';
                    $subject = translate('LBL_PAYPAL_ADMIN_CANCEL_SUBSCRIPTION_TITLE', 'stic_Web_Forms') . ': ' . $PCBean->paypal_subscr_id;
                    $paymentMailer->sendPaypalInfo($PCBean->assigned_user_id, $subject, $body);
                } else {
                    // Send IPN message to all admin users
                    $body = "<div><h3>Paypal IPN [{$txnType}]</h3><pre>" . print_r($ipnMessage, true) . '</pre></div>';
                    $subject = translate('LBL_PAYPAL_ADMIN_CANT_GET_PAYMENT_COMMITMENT', 'stic_Web_Forms') . " [{$txnType}]";
                    $paymentMailer->sendPaypalInfo('', $subject, $body);
                }
                break;

            default:
                // Send IPN message to all admin users
                $body = "<div><h3>Paypal IPN [{$txnType}]</h3><pre>" . print_r($ipnMessage, true) . '</pre></div>';
                $subject = translate('LBL_PAYPAL_ADMIN_UNKNOWN_MESSAGE', 'stic_Web_Forms') . " [{$txnType}]";
                $paymentMailer->sendPaypalInfo('', $subject, $body);
                $GLOBALS['log']->error('Line ' . __LINE__ . ': ' . __METHOD__ . ": An IPN message of the type [{$txnType}] has been received, but there is no defined way to process it.");
                break;
        }

        return $this->returnCode($ret);
    }

    /**
     * Process a Stripe received event
     *
     * @param Stripe\Event $event The event to be processed
     * @param string $transaction_code (By reference) Fills the transaction_code related to the event
     * @param string $retCode (By reference) Fills the return Code of the process
     * @return boolean Says if the event is correctly processed
     */
    public function processStripeEvent($event, &$transaction_code, &$retCode) {
        if ($event == null) {
            $retCode = "STRIPE_INVALID_EVENT";
            return false;
        }

        $paymentMailer = new PaymentMailer();

        // Handle the event according to its type
        switch ($event->type) {
            case 'checkout.session.completed':
            case 'checkout.session.async_payment_failed':
            case 'checkout.session.async_payment_succeeded':
            case 'checkout.session.expired':
                return $this->processStripeCheckout($event->data->object, $event->type, $paymentMailer, $transaction_code, $retCode);

            case 'customer.subscription.deleted':
                return $this->processStripeSubscription($event->data->object, $event->type, $paymentMailer, $retCode);

            case 'invoice.payment_succeeded':
                return $this->processStripeInvoice($event->data->object, $event->type, $paymentMailer, $retCode);
            default:
                // If the event is not one of filtered simply log a debug entry
                $GLOBALS['log']->debug("Entrypoint File: StripeResponse.php: Not a Stripe response to manage... {$event->type}");
                // Returns event processed to prevent Stripe throw it again
                return true;
        }
    }

    /**
     * Process a Stripe Checkout event
     *
     * @param Stripe\Checkout\Session $session
     * @param string $eventType
     * @param PaymentMailer $paymentMailer
     * @param string $transaction_code
     * @param string $retCode
     * @return boolean
     */
    private function processStripeCheckout($session, $eventType, $paymentMailer, &$transaction_code, &$retCode) {
        if ($session == null) {
            $retCode = "STRIPE_INVALID_SESSION";
            return false;
        }

        // Load Data with Stripe Session
        if (!$this->loadPaymentBeansFromStripeSession($session, $transaction_code)) {
            // Data can not be retrieved from DB: Can not process the event. Stripe will throw it again later

            // Send Event message to all admin users
            $body = "<div><h3>Stripe Event [{$eventType}]</h3><pre>" . print_r($session, true) . '</pre></div>';
            if ($this->getLastPC() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT_COMMITMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            if ($this->getLastPayment() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            $paymentMailer->sendStripeInfo('', $subject, $body);
            
            $retCode = "STRIPE_PAYMENT_NOT_FOUND";
            return false; 
        }

        $paymentBean = $this->getLastPayment();
        switch ($eventType) {
            case 'checkout.session.completed':
            case 'checkout.session.async_payment_succeeded':
                $paymentBean->status = 'paid';
                $paymentBean->amount = $session->amount_total/100;
                $paymentBean->gateway_log .= '##### ' . print_r($session, true);
                break;
            case 'checkout.session.async_payment_failed':
                $paymentBean->status = 'pending';
                $paymentBean->gateway_log .= '##### ' . print_r($session, true);
                break;
            case 'checkout.session.expired':
                $paymentBean->status = 'rejected_gateway';
                $paymentBean->gateway_log .= '##### ' . print_r($session, true);
                break;
            default:
        }
        $paymentBean->save();

        return true;
    }

    /**
     * Load the Payment Bean and PaymentCommitment Bean related to a Stripe Session
     *
     * @param Stripe\Checkout\Session $session
     * @param string $transaction_code
     * @return boolean
     */
    private function loadPaymentBeansFromStripeSession($session, &$transaction_code) {
        require_once 'SticInclude/Utils.php';

        $paymentBean = null;
        $pcBean = null;

        // Recover the transaction code (payment)
        $transaction_code = $session->metadata['transaction_code'];
        if (!empty($transaction_code)) {
            // Load the Payment from transaction_code, then the Payment Commitment
            $paymentBean = BeanFactory::getBean('stic_Payments');
            $paymentBean = $paymentBean->retrieve_by_string_fields(array('transaction_code' => $transaction_code));
            $pcBean = SticUtils::getRelatedBeanObject($paymentBean, 'stic_payments_stic_payment_commitments');
            // Update Subscription Id
            if ($session->subscription != null) {
                $pcBean->stripe_subscr_id = $session->subscription;
                $pcBean->save();
            }
        } else {
            if ($session->subscription != null) {
                // Load the Payment Commitment from subscription, then the Payment
                $pcBean = Beanfactory::getBean('stic_Payment_Commitments');
                $pcBean = $pcBean->retrieve_by_string_fields(array('stripe_subscr_id' => $session->subscription));
                $paymentBean = $this->getBeanPaymentFromStripePaymentCommitment($pcBean, $session->created);
            }
        }

        $this->setLastPayment($paymentBean);
        $this->setLastPC($pcBean);

        return $this->getLastPC()!=null && $this->getLastPayment()!=null;
    }
    
    /**
     * Process a Stripe Invoice event
     *
     * @param Stripe\Invoice $invoice
     * @param string $eventType
     * @param PaymentMailer $paymentMailer
     * @param string $retCode
     * @return boolean
     */
    private function processStripeInvoice($invoice, $eventType, $paymentMailer, &$retCode) {
        if ($invoice == null) {
            $retCode = "STRIPE_INVALID_INVOICE";
            return false;
        }
        
        // Process only invoice payments
        if ($eventType != 'invoice.payment_succeeded') {
            return true;
        }

        // Load Data with Stripe Invoice
        if (!$this->loadPaymentBeansFromStripeInvoice($invoice)) {
            // Data can not be retrieved from DB: Can not process the event. Stripe will throw it again later
            // Send Event message to all admin users
            $body = "<div><h3>Stripe Event [{$eventType}]</h3><pre>" . print_r($invoice, true) . '</pre></div>';
            if ($this->getLastPC() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT_COMMITMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            if ($this->getLastPayment() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            $paymentMailer->sendStripeInfo('', $subject, $body);
            
            $retCode = "STRIPE_PAYMENT_NOT_FOUND";
            return false; 
        }
        $paymentBean = $this->getLastPayment();
        if ($invoice->paid) {
            $paymentBean->status = 'paid';
            $paymentBean->amount = $invoice->amount_paid/100;
        } else {
            $paymentBean->status = 'pending';
        }
        $paymentBean->gateway_log .= '##### ' . print_r($invoice, true);
        $paymentBean->save();

        return true;
    }

    /**
     * Load the Payment Bean and PaymentCommitment Bean related to a Stripe Invoice
     *
     * @param Stripe\Invoice $invoice
     * @return boolean
     */
    private function loadPaymentBeansFromStripeInvoice($invoice) {
        $paymentBean = null;
        $pcBean = null;

        if ($invoice->subscription != null) {
            // Load the Payment Commitment from subscription, then the Payment
            $pcBean = Beanfactory::getBean('stic_Payment_Commitments');
            $pcBean = $pcBean->retrieve_by_string_fields(array('stripe_subscr_id' => $invoice->subscription));
            $paymentBean = $this->getBeanPaymentFromStripePaymentCommitment($pcBean, $invoice->created);
        }

        $this->setLastPayment($paymentBean);
        $this->setLastPC($pcBean);

        return $this->getLastPC()!=null && $this->getLastPayment()!=null;
    }

    /**
     * Process a Stripe Subscription event
     *
     * @param Stripe\Subscription $subscription
     * @param string $eventType
     * @param PaymentMailer $paymentMailer
     * @param string $retCode
     * @return boolean
     */
    private function processStripeSubscription($subscription, $eventType, $paymentMailer, &$retCode) {
        if ($subscription == null) {
            $retCode = "STRIPE_INVALID_SUBSCRIPTION";
            return false;
        }

        // Process only deleted subscriptions
        if ($eventType != 'customer.subscription.deleted') {
            return true;
        }

        // Load Data with Stripe Subscription
        if (!$this->loadPaymentBeansFromStripeSubscription($subscription)) {
            // Data can not be retrieved from DB: Can not process the event. Stripe will throw it again later
            // Send Event message to all admin users
            $body = "<div><h3>Stripe Event [{$eventType}]</h3><pre>" . print_r($subscription, true) . '</pre></div>';
            if ($this->getLastPC() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT_COMMITMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            if ($this->getLastPayment() == null) {
                $subject = translate('LBL_STRIPE_ADMIN_CANT_GET_PAYMENT', 'stic_Web_Forms') . " [{$eventType}]";
            }
            $paymentMailer->sendStripeInfo('', $subject, $body);

            $retCode = "STRIPE_PAYMENT_NOT_FOUND";
            return false; 
        }
        $pcBean = $this->getLastPC();

        // Update end date
        if (!empty($subscription->ended_at)) {
            $pcBean->end_date = date('Y-m-d H:i:s', $subscription->ended_at);
            $pcBean->gateway_log .= '##### ' . print_r($subscription, true);
            $pcBean->save();
        }
        return true;
    }

    /**
     * Load the Payment Bean and PaymentCommitment Bean related to a Stripe Subscription
     *
     * @param Stripe\Subscription $subscription
     * @return boolean
     */
    private function loadPaymentBeansFromStripeSubscription($subscription) {
        require_once 'SticInclude/Utils.php';

        $pcBean = null;

        // Load the Payment Commitment from subscription, then the Payment
        $pcBean = Beanfactory::getBean('stic_Payment_Commitments');
        $pcBean = $pcBean->retrieve_by_string_fields(array('stripe_subscr_id' => $subscription->id));
        
        $this->setLastPayment(null);
        $this->setLastPC($pcBean);

        return $pcBean!=null;
    }

    private function getBeanPaymentFromStripePaymentCommitment($pcBean, $paymentTimestamp)
    {
        $pcId = $pcBean->id;
        $paymentDate = date('Ym', $paymentTimestamp);
        $paymentIdSQL ="SELECT p.id
                        FROM stic_payments p
                            INNER JOIN stic_payments_stic_payment_commitments_c rel 
                                ON p.id = rel.stic_payments_stic_payment_commitmentsstic_payments_idb
                            INNER JOIN stic_payment_commitments pc 
                                ON pc.id = rel.stic_paymebfe2itments_ida
                        WHERE pc.Id = '{$pcId}'
                            AND p.deleted = 0
                            AND rel.deleted = 0
                            AND p.deleted = 0
                            AND date_format(p.payment_date, '%Y%m') = {$paymentDate}
                        LIMIT 1";
        $paymentId = $GLOBALS['db']->getOne($paymentIdSQL);

        if (!empty($paymentId)) {
            $paymentBean = BeanFactory::getBean('stic_Payments', $paymentId);
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Retrieved {$paymentId} payment for [{$pcBean->stripe_subscr_id}] Stripe subscription with date {$paymentDate}.");
        } else {
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": No payment has been found for [{$pcBean->stripe_subscr_id}] Stripe subscription with date {$paymentDate}.");
        }

        if ($paymentBean->id) {
            return $paymentBean;
        } else {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ":  The payment referred in the Stripe event could not be retrieved: subscr_id {$pcBean->stripe_subscr_id}, for date {$paymentDate}");
        }
    }

    /**
     * Get the payment referred by an IPN message. It must be a pending payment with the same amount and date referred by PayPal
     *
     * @param Array $ipnMessage IPN message content
     * @return Object payment bean
     */
    private function getPaymentByIPNMessage($ipnMessage)
    {
        $paymentDate = date('Ym', strtotime($ipnMessage['payment_date']));
        $paymentIdSQL = "SELECT
                            p.id
                        FROM
                            stic_payment_commitments pc
                        JOIN stic_payments_stic_payment_commitments_c rel on
                            rel.stic_paymebfe2itments_ida = pc.id
                        JOIN stic_payments p on
                            p.id = rel.stic_payments_stic_payment_commitmentsstic_payments_idb
                        WHERE
                            TRIM(pc.paypal_subscr_id) != ''
                            AND pc.paypal_subscr_id = '{$ipnMessage['subscr_id']}'
                            AND p.status = 'pending'
                            AND date_format(p.payment_date, '%Y%m') = {$paymentDate}
                            AND p.deleted = 0
                            AND rel.deleted = 0
                            AND p.deleted = 0
                        LIMIT 1";
        $paymentId = $GLOBALS['db']->getOne($paymentIdSQL);

        // Sometimes, on subscription creation, "subscr_payment" response (for first payment) is received before than "subscr_signup" response,
        // so "paypal_subscr_id" is still not set in the payment commitment and the payment can't be retrieved this way. In that case, will try
        // to retrieve it using CRM transaction_code field.
        if (!empty($paymentId)) {
            $paymentBean = BeanFactory::getBean('stic_Payments', $paymentId);
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Retrieved {$paymentId} payment for [{$ipnMessage['subscr_id']}] PayPal subscription.");
        } else {
            $transactionCode = $ipnMessage['custom'];
            $paymentBean = Beanfactory::getBean('stic_Payments');
            $paymentBean->retrieve_by_string_fields(array('transaction_code' => $transactionCode));
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": No payment has been found for [{$ipnMessage['subscr_id']}] PayPal subscription. Will try with transaction code [{$transactionCode}].");
        }

        if ($paymentBean->id) {
            return $paymentBean;
        } else {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ":  The payment referred in the IPN message could not be retrieved: subscr_id {$ipnMessage['subscr_id']} | transaction code {$ipnMessage['custom']}");
        }
    }

    /**
     * Get the payment commitment using suscription id contained in PayPal IPN message
     *
     * @param String $subscrId Paypal subscription id
     * @return Object payment commitment bean
     */
    private function getPaymentCommitmentByIPNSubscrId($subscrId)
    {
        $PCBean = Beanfactory::getBean('stic_Payment_Commitments');
        $PCBean = $PCBean->retrieve_by_string_fields(array('paypal_subscr_id' => $subscrId));

        if ($PCBean) {
            return $PCBean;
        } else {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": The payment commitment could not be retrieved by subscr_id: subscr_id {$subscrId}");
        }
    }

    /**
     * Get the payment commitment using transaction code contained in PayPal IPN message
     *
     * @param String $transactionCode transaction code
     * @return Object payment commitment bean
     */
    private function getPaymentCommitmentByIPNTransactionCode($transactionCode)
    {

        $transactionCode = intval($transactionCode);

        $PCIdSql = "SELECT
                rel.stic_paymebfe2itments_ida
            FROM
                stic_payments p
            INNER JOIN stic_payments_stic_payment_commitments_c rel ON
                p.id = rel.stic_payments_stic_payment_commitmentsstic_payments_idb
                AND p.deleted = 0
                AND rel.deleted = 0
                AND p.transaction_code = '{$transactionCode}'";

        $PCId = $GLOBALS['db']->getOne($PCIdSql);

        $PCBean = Beanfactory::getBean('stic_Payment_Commitments', $PCId);

        if ($PCBean->id) {
            return $PCBean;
        } else {
            $GLOBALS['log']->fatal('Line ' . __LINE__ . ': ' . __METHOD__ . ": The payment commitment could not be retrieved by transaction_code: transaction_code {$transactionCode}");
        }
    }

    /**
     * Disable related payment commitment by setting end_date
     *
     * @param Object $paymentBean
     * @return void
     */
    private static function disablePaymentCommitment($paymentBean)
    {
        require_once 'SticInclude/Utils.php';
        $PCBean = SticUtils::getRelatedBeanObject($paymentBean, 'stic_payments_stic_payment_commitments');
        if ($PCBean->periodicity != 'punctual') {
            $PCBean->end_date = date('Y-m-d');
            $PCBean->save(false);
            $GLOBALS['log']->debug('Line ' . __LINE__ . ': ' . __METHOD__ . ": Payment commitment [{$PCBean->id}] has been deactivated (end_date = today) because the first payment has been rejected by the TPV.");
        }
    }

}
